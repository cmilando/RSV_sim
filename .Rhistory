sim.init()
sim.run()
if do_plot:
plt.figure()
plt.plot(sim.timevec, sim.results.gonorrhea.n_infected)
plt.title('Number of gonorrhea infections')
plt.title('Number of gonorrhea infections')
plt.figure()
plt.plot(sim.timevec, sim.results.gonorrhea.n_infected)
plt.title('Number of gonorrhea infections')
# Possible to initialize people with extra states, e.g. a geolocation
def geo_func(n):
locs = [1,2,3]
return np.random.choice(locs, n)
extra_states = [
ss.FloatArr('geolocation', default=geo_func),
]
ppl = ss.People(small, extra_states=extra_states)
# Possible to add a module to people outside a sim (not typical workflow)
ppl.add_module(sse.HIV())
ppl.to_df()
def geo_func(n):
locs = [1,2,3]
return np.random.choice(locs, n)
extra_states = [
ss.FloatArr('geolocation', default=geo_func),
]
ppl = ss.People(small, extra_states=extra_states)
def geo_func(n):
locs = [1,2,3]
return np.random.choice(locs, n)
extra_states = [ss.FloatArr('geolocation', default=geo_func)]
library(ggplot2)
set.seed(123)
n <- 20
i <- 1:n
j <- 1:n
## -------- 1. Your main matrix 'mat' --------
decay_scale <- 6
band_mat   <- outer(i, j, function(a, b) exp(-abs(a - b) / decay_scale))
trend_mat  <- outer(i, j, function(a, b) {
((n + 1 - a) * (n + 1 - b)) / n^2   # strongest at bottom-left
})
signal_mat <- band_mat * trend_mat
noise_raw <- matrix(rnorm(n * n), n, n)
kernel <- matrix(c(1, 2, 1,
2, 4, 2,
1, 2, 1), nrow = 3, byrow = TRUE)
kernel <- kernel / sum(kernel)
smooth2d <- function(mat, kern) {
pad <- floor(nrow(kern) / 2)
nr  <- nrow(mat); nc <- ncol(mat)
ext <- matrix(0, nr + 2 * pad, nc + 2 * pad)
ext[(pad + 1):(pad + nr), (pad + 1):(pad + nc)] <- mat
out <- matrix(0, nr, nc)
for (r in 1:nr) {
for (c in 1:nc) {
sub <- ext[r:(r + 2 * pad), c:(c + 2 * pad)]
out[r, c] <- sum(sub * kern)
}
}
out
}
noise_smooth <- smooth2d(noise_raw, kernel)
lower_mask <- row(noise_smooth) > col(noise_smooth)
noise_smooth[lower_mask] <- noise_smooth[lower_mask] * 0.8
noise_smooth[!lower_mask] <- noise_smooth[!lower_mask] * 1.2
mat <- signal_mat + 0.2 * noise_smooth
mat <- mat - min(mat)
mat <- mat / max(mat)   # scale to [0,1]
## -------- 2. Split mat into 4 blocky components --------
n <- nrow(mat)
K <- 4               # number of components
block_size <- 10     # side length of each block in cells
# how many blocks in each direction (round up)
nb_row <- ceiling(n / block_size)
nb_col <- ceiling(n / block_size)
# small smoothing kernel (optional, for correlated-looking blocks)
kernel <- matrix(c(1, 2, 1,
2, 4, 2,
1, 2, 1), nrow = 3, byrow = TRUE)
kernel <- kernel / sum(kernel)
smooth2d <- function(mat, kern) {
mat <- as.matrix(mat)
pad <- floor(nrow(kern) / 2)
nr  <- nrow(mat); nc <- ncol(mat)
ext <- matrix(0, nr + 2 * pad, nc + 2 * pad)
ext[(pad + 1):(pad + nr), (pad + 1):(pad + nc)] <- mat
out <- matrix(0, nr, nc)
for (r in 1:nr) {
for (c in 1:nc) {
sub <- ext[r:(r + 2 * pad), c:(c + 2 * pad)]
out[r, c] <- sum(sub * kern)
}
}
out
}
components_raw <- vector("list", K)
set.seed(123)
for (k in 1:K) {
# 1) random value per *square block*
block_vals <- matrix(runif(nb_row * nb_col), nb_row, nb_col)
# 2) expand to a full matrix of squares via kronecker
#    each block is block_size x block_size
base_big <- kronecker(block_vals, matrix(1, block_size, block_size))
# 3) crop to exactly n x n (in case n not multiple of block_size)
base <- base_big[1:n, 1:n]
# 4) optional smoothing to make blocks look correlated, less “lego”
components_raw[[k]] <- smooth2d(base, kernel)
# If you want *crisp* squares, instead do:
# components_raw[[k]] <- base
#
dnn <- levels(cut(0:100, breaks = n, include.lowest = T))
row.names(components_raw[[k]]) <- dnn
colnames(components_raw[[k]]) <- dnn
}
# normalize each raw component to [0, 1]
components_raw <- lapply(components_raw, function(x) {
x <- x - min(x)
x / max(x)
})
# reweight so that the components sum exactly to mat
total_raw <- Reduce("+", components_raw) + 1e-8  # avoid divide-by-zero
components <- lapply(components_raw, function(b) mat * b / total_raw)
# sanity check: max difference should be tiny
max(abs(mat - Reduce("+", components)))
## -------- 3. Plot one or more components --------
plot_comp <- function(comp, title) {
df <- as.data.frame(as.table(comp))
names(df) <- c("i", "j", "z")
ggplot(df, aes(i, j, fill = z)) +
geom_tile() +
scale_fill_gradientn(colors = blues9,
limits = c(0, 1)) +
coord_fixed() +
ggtitle(title) +
theme_minimal()
}
# Example: plot components 1–4
plot_comp(components[[1]], "Component 1")
plot_comp(components[[2]], "Component 2")
plot_comp(components[[3]], "Component 3")
plot_comp(components[[4]], "Component 4")
plot_comp(components[[1]] +
components[[2]] +
components[[3]] +
components[[4]], "Components all")
# Example: plot components 1–4
plot_comp(components[[1]], "Component 1")
plot_comp(components[[2]], "Component 2")
plot_comp(components[[3]], "Component 3")
library(ggplot2)
set.seed(123)
n <- 20
i <- 1:n
j <- 1:n
## -------- 1. Your main matrix 'mat' --------
decay_scale <- 6
band_mat   <- outer(i, j, function(a, b) exp(-abs(a - b) / decay_scale))
trend_mat  <- outer(i, j, function(a, b) {
((n + 1 - a) * (n + 1 - b)) / n^2   # strongest at bottom-left
})
signal_mat <- band_mat * trend_mat
noise_raw <- matrix(rnorm(n * n), n, n)
kernel <- matrix(c(1, 2, 1,
2, 4, 2,
1, 2, 1), nrow = 3, byrow = TRUE)
kernel <- kernel / sum(kernel)
smooth2d <- function(mat, kern) {
pad <- floor(nrow(kern) / 2)
nr  <- nrow(mat); nc <- ncol(mat)
ext <- matrix(0, nr + 2 * pad, nc + 2 * pad)
ext[(pad + 1):(pad + nr), (pad + 1):(pad + nc)] <- mat
out <- matrix(0, nr, nc)
for (r in 1:nr) {
for (c in 1:nc) {
sub <- ext[r:(r + 2 * pad), c:(c + 2 * pad)]
out[r, c] <- sum(sub * kern)
}
}
out
}
noise_smooth <- smooth2d(noise_raw, kernel)
lower_mask <- row(noise_smooth) > col(noise_smooth)
noise_smooth[lower_mask] <- noise_smooth[lower_mask] * 0.8
noise_smooth[!lower_mask] <- noise_smooth[!lower_mask] * 1.2
mat <- signal_mat + 0.2 * noise_smooth
mat <- mat - min(mat)
mat <- mat / max(mat)   # scale to [0,1]
## -------- 2. Split mat into 4 blocky components --------
n <- nrow(mat)
K <- 3               # number of components
block_size <- 10     # side length of each block in cells
# how many blocks in each direction (round up)
nb_row <- ceiling(n / block_size)
nb_col <- ceiling(n / block_size)
# small smoothing kernel (optional, for correlated-looking blocks)
kernel <- matrix(c(1, 2, 1,
2, 4, 2,
1, 2, 1), nrow = 3, byrow = TRUE)
kernel <- kernel / sum(kernel)
smooth2d <- function(mat, kern) {
mat <- as.matrix(mat)
pad <- floor(nrow(kern) / 2)
nr  <- nrow(mat); nc <- ncol(mat)
ext <- matrix(0, nr + 2 * pad, nc + 2 * pad)
ext[(pad + 1):(pad + nr), (pad + 1):(pad + nc)] <- mat
out <- matrix(0, nr, nc)
for (r in 1:nr) {
for (c in 1:nc) {
sub <- ext[r:(r + 2 * pad), c:(c + 2 * pad)]
out[r, c] <- sum(sub * kern)
}
}
out
}
components_raw <- vector("list", K)
set.seed(123)
for (k in 1:K) {
# 1) random value per *square block*
block_vals <- matrix(runif(nb_row * nb_col), nb_row, nb_col)
# 2) expand to a full matrix of squares via kronecker
#    each block is block_size x block_size
base_big <- kronecker(block_vals, matrix(1, block_size, block_size))
# 3) crop to exactly n x n (in case n not multiple of block_size)
base <- base_big[1:n, 1:n]
# 4) optional smoothing to make blocks look correlated, less “lego”
components_raw[[k]] <- smooth2d(base, kernel)
# If you want *crisp* squares, instead do:
# components_raw[[k]] <- base
#
dnn <- levels(cut(0:100, breaks = n, include.lowest = T))
row.names(components_raw[[k]]) <- dnn
colnames(components_raw[[k]]) <- dnn
}
# normalize each raw component to [0, 1]
components_raw <- lapply(components_raw, function(x) {
x <- x - min(x)
x / max(x)
})
# reweight so that the components sum exactly to mat
total_raw <- Reduce("+", components_raw) + 1e-8  # avoid divide-by-zero
components <- lapply(components_raw, function(b) mat * b / total_raw)
# sanity check: max difference should be tiny
max(abs(mat - Reduce("+", components)))
## -------- 3. Plot one or more components --------
plot_comp <- function(comp, title) {
df <- as.data.frame(as.table(comp))
names(df) <- c("i", "j", "z")
ggplot(df, aes(i, j, fill = z)) +
geom_tile() +
scale_fill_gradientn(colors = blues9,
limits = c(0, 1)) +
coord_fixed() +
ggtitle(title) +
theme_minimal()
}
# Example: plot components 1–4
plot_comp(components[[1]], "Component 1")
plot_comp(components[[2]], "Component 2")
plot_comp(components[[3]], "Component 3")
plot_comp(components[[1]] +
components[[2]] +
components[[3]], "Components all")
## -------- 4. Write to XLSX --------
library(writexl)
# assume 'components' is your list of matrices
# convert each matrix to a data frame for Excel
full_comp <- components[[1]] +
components[[2]] +
components[[3]]
components[[4]] <- full_comp
components_dfs <- lapply(components, as.data.frame)
# give each sheet a name
names(components_dfs) <- c(paste0("component_", 1:3),"components_full")
# write to a single Excel workbook
write_xlsx(components_dfs, "components_decomposition.xlsx")
# Example: plot components 1–4
library(patchwork)
p1 <- plot_comp(components[[1]], "Component 1")
p2 <- plot_comp(components[[2]], "Component 2")
p3 <- plot_comp(components[[3]], "Component 3")
p4 <- plot_comp(components[[1]] +
components[[2]] +
components[[3]], "Components all")
(p1 + p2) / (p3 + p4)
(p1 + p2) / (p3 + p4) + plot_layout(axes = 'collect')
(p1 + p2) / (p3 + p4) + plot_layout(guides = 'collect')
library(writexl)
# assume 'components' is your list of matrices
# convert each matrix to a data frame for Excel
full_comp <- components[[1]] +
components[[2]] +
components[[3]]
components[[4]] <- full_comp
components_dfs <- lapply(components, as.data.frame)
# give each sheet a name
names(components_dfs) <- c(paste0("component_", 1:k),"components_full")
# write to a single Excel workbook
write_xlsx(components_dfs, "components_decomposition.xlsx")
plot_comp <- function(comp, title) {
df <- as.data.frame(as.table(comp))
names(df) <- c("i", "j", "z")
ggplot(df, aes(i, j, fill = z)) +
geom_tile() +
scale_fill_gradientn(colors = blues9,
limits = c(0, 1)) +
coord_fixed() +
ggtitle(title) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 0))
}
# Example: plot components 1–4
library(patchwork)
p1 <- plot_comp(components[[1]], "Component 1")
p2 <- plot_comp(components[[2]], "Component 2")
p3 <- plot_comp(components[[3]], "Component 3")
p4 <- plot_comp(components[[1]] +
components[[2]] +
components[[3]], "Components all")
(p1 + p2) / (p3 + p4) + plot_layout(guides = 'collect')
ggplot(df, aes(i, j, fill = z)) +
geom_tile() +
scale_fill_gradientn(colors = blues9,
limits = c(0, 1)) +
coord_fixed() +
ggtitle(title) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
plot_comp <- function(comp, title) {
df <- as.data.frame(as.table(comp))
names(df) <- c("i", "j", "z")
ggplot(df, aes(i, j, fill = z)) +
geom_tile() +
scale_fill_gradientn(colors = blues9,
limits = c(0, 1)) +
coord_fixed() +
ggtitle(title) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
}
# Example: plot components 1–4
library(patchwork)
p1 <- plot_comp(components[[1]], "Component 1")
p2 <- plot_comp(components[[2]], "Component 2")
p3 <- plot_comp(components[[3]], "Component 3")
p4 <- plot_comp(components[[1]] +
components[[2]] +
components[[3]], "Components all")
(p1 + p2) / (p3 + p4) + plot_layout(guides = 'collect')
p1 <- plot_comp(components[[1]], "Household")
p2 <- plot_comp(components[[2]], "School")
p3 <- plot_comp(components[[3]], "Community")
p4 <- plot_comp(components[[1]] +
components[[2]] +
components[[3]], "Combined")
(p1 + p2) / (p3 + p4) + plot_layout(guides = 'collect')
library(ggplot2)
set.seed(123)
n <- 20
i <- 1:n
j <- 1:n
## -------- 1. Your main matrix 'mat' --------
decay_scale <- 6
band_mat   <- outer(i, j, function(a, b) exp(-abs(a - b) / decay_scale))
trend_mat  <- outer(i, j, function(a, b) {
((n + 1 - a) * (n + 1 - b)) / n^2   # strongest at bottom-left
})
signal_mat <- band_mat * trend_mat
noise_raw <- matrix(rnorm(n * n), n, n)
kernel <- matrix(c(1, 2, 1,
2, 4, 2,
1, 2, 1), nrow = 3, byrow = TRUE)
kernel <- kernel / sum(kernel)
smooth2d <- function(mat, kern) {
pad <- floor(nrow(kern) / 2)
nr  <- nrow(mat); nc <- ncol(mat)
ext <- matrix(0, nr + 2 * pad, nc + 2 * pad)
ext[(pad + 1):(pad + nr), (pad + 1):(pad + nc)] <- mat
out <- matrix(0, nr, nc)
for (r in 1:nr) {
for (c in 1:nc) {
sub <- ext[r:(r + 2 * pad), c:(c + 2 * pad)]
out[r, c] <- sum(sub * kern)
}
}
out
}
noise_smooth <- smooth2d(noise_raw, kernel)
lower_mask <- row(noise_smooth) > col(noise_smooth)
noise_smooth[lower_mask] <- noise_smooth[lower_mask] * 0.8
noise_smooth[!lower_mask] <- noise_smooth[!lower_mask] * 1.2
mat <- signal_mat + 0.2 * noise_smooth
mat <- mat - min(mat)
mat <- mat / max(mat)   # scale to [0,1]
## -------- 2. Split mat into 4 blocky components --------
n <- nrow(mat)
K <- 3               # number of components
block_size <- 10     # side length of each block in cells
# how many blocks in each direction (round up)
nb_row <- ceiling(n / block_size)
nb_col <- ceiling(n / block_size)
# small smoothing kernel (optional, for correlated-looking blocks)
kernel <- matrix(c(1, 2, 1,
2, 4, 2,
1, 2, 1), nrow = 3, byrow = TRUE)
kernel <- kernel / sum(kernel)
smooth2d <- function(mat, kern) {
mat <- as.matrix(mat)
pad <- floor(nrow(kern) / 2)
nr  <- nrow(mat); nc <- ncol(mat)
ext <- matrix(0, nr + 2 * pad, nc + 2 * pad)
ext[(pad + 1):(pad + nr), (pad + 1):(pad + nc)] <- mat
out <- matrix(0, nr, nc)
for (r in 1:nr) {
for (c in 1:nc) {
sub <- ext[r:(r + 2 * pad), c:(c + 2 * pad)]
out[r, c] <- sum(sub * kern)
}
}
out
}
components_raw <- vector("list", K)
set.seed(123)
for (k in 1:K) {
# 1) random value per *square block*
block_vals <- matrix(runif(nb_row * nb_col), nb_row, nb_col)
# 2) expand to a full matrix of squares via kronecker
#    each block is block_size x block_size
base_big <- kronecker(block_vals, matrix(1, block_size, block_size))
# 3) crop to exactly n x n (in case n not multiple of block_size)
base <- base_big[1:n, 1:n]
# 4) optional smoothing to make blocks look correlated, less “lego”
components_raw[[k]] <- smooth2d(base, kernel)
# If you want *crisp* squares, instead do:
# components_raw[[k]] <- base
#
dnn <- levels(cut(0:100, breaks = n, include.lowest = T))
row.names(components_raw[[k]]) <- dnn
colnames(components_raw[[k]]) <- dnn
}
# normalize each raw component to [0, 1]
components_raw <- lapply(components_raw, function(x) {
x <- x - min(x)
x / max(x)
})
# reweight so that the components sum exactly to mat
total_raw <- Reduce("+", components_raw) + 1e-8  # avoid divide-by-zero
components <- lapply(components_raw, function(b) mat * b / total_raw)
# sanity check: max difference should be tiny
max(abs(mat - Reduce("+", components)))
## -------- 3. Plot one or more components --------
plot_comp <- function(comp, title) {
df <- as.data.frame(as.table(comp))
names(df) <- c("i", "j", "z")
ggplot(df, aes(i, j, fill = z)) +
geom_tile() +
scale_fill_gradientn(colors = blues9,
limits = c(0, 1)) +
coord_fixed() +
ggtitle(title) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
}
# Example: plot components 1–4
library(patchwork)
p1 <- plot_comp(components[[1]], "Household")
p2 <- plot_comp(components[[2]], "School")
p3 <- plot_comp(components[[3]], "Community")
p4 <- plot_comp(components[[1]] +
components[[2]] +
components[[3]], "Combined")
(p1 + p2) / (p3 + p4) + plot_layout(guides = 'collect')
## -------- 4. Write to XLSX --------
library(writexl)
# assume 'components' is your list of matrices
# convert each matrix to a data frame for Excel
full_comp <- components[[1]] +
components[[2]] +
components[[3]]
components[[4]] <- full_comp
components_dfs <- lapply(components, as.data.frame)
# give each sheet a name
names(components_dfs) <- c("Household", 'School', 'Community', 'Combined')
# write to a single Excel workbook
write_xlsx(components_dfs, "components_decomposition.xlsx")
## -------- 4. Write to a block identity matrix csv --------
library(Matrix)
# Create a block identity matrix using bdiag
block_identity_matrix <- bdiag(components[[1]],
components[[2]],
components[[3]])
# View the resulting matrix
print(block_identity_matrix)
# View the resulting matrix
write.csv(block_identity_matrix,
file = 'contact_matrix.csv', quote = F, row.names = F, col.names = F)
# View the resulting matrix
write.csv(as.matrix(block_identity_matrix),
file = 'contact_matrix.csv', quote = F, row.names = F, col.names = F)
# View the resulting matrix
write.csv(as.matrix(block_identity_matrix),
file = 'contact_matrix.csv', quote = F, row.names = F,header = F)
# View the resulting matrix
write.csv(as.matrix(block_identity_matrix),col.names = F,
file = 'contact_matrix.csv', quote = F, row.names = F)
# View the resulting matrix
write.table(as.matrix(block_identity_matrix),sep = ",", col.names = False,
file = 'contact_matrix.csv', quote = F, row.names = F)
# View the resulting matrix
write.table(as.matrix(block_identity_matrix),sep = ",", col.names = F,
file = 'contact_matrix.csv', quote = F, row.names = F)
