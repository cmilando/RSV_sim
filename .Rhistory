plot_comp(components[[4]], "Component 4")
plot_comp(components[[1]] +
components[[2]] +
components[[3]] +
components[[4]], "Components all")
# Example: plot components 1–4
plot_comp(components[[1]], "Component 1")
plot_comp(components[[2]], "Component 2")
plot_comp(components[[3]], "Component 3")
library(ggplot2)
set.seed(123)
n <- 80
i <- 1:n
j <- 1:n
## -------- 1. Your main matrix 'mat' --------
decay_scale <- 6
band_mat   <- outer(i, j, function(a, b) exp(-abs(a - b) / decay_scale))
trend_mat  <- outer(i, j, function(a, b) {
((n + 1 - a) * (n + 1 - b)) / n^2   # strongest at bottom-left
})
signal_mat <- band_mat * trend_mat
noise_raw <- matrix(rnorm(n * n), n, n)
kernel <- matrix(c(1, 2, 1,
2, 4, 2,
1, 2, 1), nrow = 3, byrow = TRUE)
kernel <- kernel / sum(kernel)
smooth2d <- function(mat, kern) {
pad <- floor(nrow(kern) / 2)
nr  <- nrow(mat); nc <- ncol(mat)
ext <- matrix(0, nr + 2 * pad, nc + 2 * pad)
ext[(pad + 1):(pad + nr), (pad + 1):(pad + nc)] <- mat
out <- matrix(0, nr, nc)
for (r in 1:nr) {
for (c in 1:nc) {
sub <- ext[r:(r + 2 * pad), c:(c + 2 * pad)]
out[r, c] <- sum(sub * kern)
}
}
out
}
noise_smooth <- smooth2d(noise_raw, kernel)
lower_mask <- row(noise_smooth) > col(noise_smooth)
noise_smooth[lower_mask] <- noise_smooth[lower_mask] * 0.8
noise_smooth[!lower_mask] <- noise_smooth[!lower_mask] * 1.2
mat <- signal_mat + 0.2 * noise_smooth
mat <- mat - min(mat)
mat <- mat / max(mat)   # scale to [0,1]
## -------- 2. Split mat into 4 blocky components --------
K  <- 4          # number of components
block_size <- 10 # pixels per block in each direction
n <- nrow(mat)
nb_row <- n / block_size   # number of blocks vertically
nb_col <- n / block_size   # number of blocks horizontally
stopifnot(nb_row == floor(nb_row), nb_col == floor(nb_col))
# helper: make a kernel-smoothed 2D field from square blocks
smooth2d <- function(mat, kern) {
mat <- as.matrix(mat)
pad <- floor(nrow(kern) / 2)
nr  <- nrow(mat); nc <- ncol(mat)
ext <- matrix(0, nr + 2 * pad, nc + 2 * pad)
ext[(pad + 1):(pad + nr), (pad + 1):(pad + nc)] <- mat
out <- matrix(0, nr, nc)
for (r in 1:nr) {
for (c in 1:nc) {
sub <- ext[r:(r + 2 * pad), c:(c + 2 * pad)]
out[r, c] <- sum(sub * kern)
}
}
out
}
# small isotropic kernel for light smoothing
kernel <- matrix(c(1, 2, 1,
2, 4, 2,
1, 2, 1), nrow = 3, byrow = TRUE)
kernel <- kernel / sum(kernel)
# block indices for each cell (now truly square blocks)
block_i <- ((row(mat) - 1) %/% block_size) + 1   # 1..nb_row
block_j <- ((col(mat) - 1) %/% block_size) + 1   # 1..nb_col
components_raw <- vector("list", K)
for (k in 1:K) {
# random value per square block
block_vals <- matrix(runif(nb_row * nb_col), nb_row, nb_col)
# expand to n x n as piecewise-constant squares
base_vec <- block_vals[cbind(block_i, block_j)]
base     <- matrix(base_vec, nrow = n, ncol = n)
# (optional) smooth to introduce correlation within/around squares
components_raw[[k]] <- smooth2d(base, kernel)
}
# normalize each component
components_raw <- lapply(components_raw, function(x) {
x <- x - min(x)
x / max(x)
})
# rescale so that components sum exactly to mat
total_raw <- Reduce("+", components_raw) + 1e-8
components <- lapply(components_raw, function(b) mat * b / total_raw)
# sanity check
max(abs(mat - Reduce("+", components)))  # should be ~ 0
## -------- 3. Plot one or more components --------
plot_comp <- function(comp, title) {
df <- as.data.frame(as.table(comp))
names(df) <- c("i", "j", "z")
ggplot(df, aes(i, j, fill = z)) +
geom_tile() +
scale_fill_gradientn(colors = blues9) +
coord_fixed() +
ggtitle(title) +
theme_minimal()
}
# Example: plot components 1–4
plot_comp(components[[1]], "Component 1")
plot_comp(components[[2]], "Component 2")
plot_comp(components[[3]], "Component 3")
plot_comp(components[[4]], "Component 4")
# plot_comp(components[[1]] +
#             components[[2]] +
#             components[[3]] +
#             components[[4]], "Components all")
library(ggplot2)
set.seed(123)
n <- 80
i <- 1:n
j <- 1:n
## -------- 1. Your main matrix 'mat' --------
decay_scale <- 6
band_mat   <- outer(i, j, function(a, b) exp(-abs(a - b) / decay_scale))
trend_mat  <- outer(i, j, function(a, b) {
((n + 1 - a) * (n + 1 - b)) / n^2   # strongest at bottom-left
})
signal_mat <- band_mat * trend_mat
noise_raw <- matrix(rnorm(n * n), n, n)
kernel <- matrix(c(1, 2, 1,
2, 4, 2,
1, 2, 1), nrow = 3, byrow = TRUE)
kernel <- kernel / sum(kernel)
smooth2d <- function(mat, kern) {
pad <- floor(nrow(kern) / 2)
nr  <- nrow(mat); nc <- ncol(mat)
ext <- matrix(0, nr + 2 * pad, nc + 2 * pad)
ext[(pad + 1):(pad + nr), (pad + 1):(pad + nc)] <- mat
out <- matrix(0, nr, nc)
for (r in 1:nr) {
for (c in 1:nc) {
sub <- ext[r:(r + 2 * pad), c:(c + 2 * pad)]
out[r, c] <- sum(sub * kern)
}
}
out
}
noise_smooth <- smooth2d(noise_raw, kernel)
lower_mask <- row(noise_smooth) > col(noise_smooth)
noise_smooth[lower_mask] <- noise_smooth[lower_mask] * 0.8
noise_smooth[!lower_mask] <- noise_smooth[!lower_mask] * 1.2
mat <- signal_mat + 0.2 * noise_smooth
mat <- mat - min(mat)
mat <- mat / max(mat)   # scale to [0,1]
## -------- 2. Split mat into 4 blocky components --------
n <- nrow(mat)
K <- 4               # number of components
block_size <- 10     # side length of each block in cells
# how many blocks in each direction (round up)
nb_row <- ceiling(n / block_size)
nb_col <- ceiling(n / block_size)
# small smoothing kernel (optional, for correlated-looking blocks)
kernel <- matrix(c(1, 2, 1,
2, 4, 2,
1, 2, 1), nrow = 3, byrow = TRUE)
kernel <- kernel / sum(kernel)
smooth2d <- function(mat, kern) {
mat <- as.matrix(mat)
pad <- floor(nrow(kern) / 2)
nr  <- nrow(mat); nc <- ncol(mat)
ext <- matrix(0, nr + 2 * pad, nc + 2 * pad)
ext[(pad + 1):(pad + nr), (pad + 1):(pad + nc)] <- mat
out <- matrix(0, nr, nc)
for (r in 1:nr) {
for (c in 1:nc) {
sub <- ext[r:(r + 2 * pad), c:(c + 2 * pad)]
out[r, c] <- sum(sub * kern)
}
}
out
}
components_raw <- vector("list", K)
set.seed(123)
for (k in 1:K) {
# 1) random value per *square block*
block_vals <- matrix(runif(nb_row * nb_col), nb_row, nb_col)
# 2) expand to a full matrix of squares via kronecker
#    each block is block_size x block_size
base_big <- kronecker(block_vals, matrix(1, block_size, block_size))
# 3) crop to exactly n x n (in case n not multiple of block_size)
base <- base_big[1:n, 1:n]
# 4) optional smoothing to make blocks look correlated, less “lego”
components_raw[[k]] <- smooth2d(base, kernel)
# If you want *crisp* squares, instead do:
# components_raw[[k]] <- base
}
# normalize each raw component to [0, 1]
components_raw <- lapply(components_raw, function(x) {
x <- x - min(x)
x / max(x)
})
# reweight so that the components sum exactly to mat
total_raw <- Reduce("+", components_raw) + 1e-8  # avoid divide-by-zero
components <- lapply(components_raw, function(b) mat * b / total_raw)
# sanity check: max difference should be tiny
max(abs(mat - Reduce("+", components)))
## -------- 3. Plot one or more components --------
plot_comp <- function(comp, title) {
df <- as.data.frame(as.table(comp))
names(df) <- c("i", "j", "z")
ggplot(df, aes(i, j, fill = z)) +
geom_tile() +
scale_fill_gradientn(colors = blues9) +
coord_fixed() +
ggtitle(title) +
theme_minimal()
}
# Example: plot components 1–4
plot_comp(components[[1]], "Component 1")
plot_comp(components[[2]], "Component 2")
plot_comp(components[[3]], "Component 3")
plot_comp(components[[4]], "Component 4")
# plot_comp(components[[1]] +
#             components[[2]] +
#             components[[3]] +
#             components[[4]], "Components all")
# Example: plot components 1–4
plot_comp(components[[1]], "Component 1")
plot_comp(components[[2]], "Component 2")
plot_comp(components[[3]], "Component 3")
plot_comp(components[[4]], "Component 4")
plot_comp(components[[1]] +
components[[2]] +
components[[3]] +
components[[4]], "Components all")
library(ggplot2)
set.seed(123)
n <- 20
i <- 1:n
j <- 1:n
## -------- 1. Your main matrix 'mat' --------
decay_scale <- 6
band_mat   <- outer(i, j, function(a, b) exp(-abs(a - b) / decay_scale))
trend_mat  <- outer(i, j, function(a, b) {
((n + 1 - a) * (n + 1 - b)) / n^2   # strongest at bottom-left
})
signal_mat <- band_mat * trend_mat
noise_raw <- matrix(rnorm(n * n), n, n)
kernel <- matrix(c(1, 2, 1,
2, 4, 2,
1, 2, 1), nrow = 3, byrow = TRUE)
kernel <- kernel / sum(kernel)
smooth2d <- function(mat, kern) {
pad <- floor(nrow(kern) / 2)
nr  <- nrow(mat); nc <- ncol(mat)
ext <- matrix(0, nr + 2 * pad, nc + 2 * pad)
ext[(pad + 1):(pad + nr), (pad + 1):(pad + nc)] <- mat
out <- matrix(0, nr, nc)
for (r in 1:nr) {
for (c in 1:nc) {
sub <- ext[r:(r + 2 * pad), c:(c + 2 * pad)]
out[r, c] <- sum(sub * kern)
}
}
out
}
noise_smooth <- smooth2d(noise_raw, kernel)
lower_mask <- row(noise_smooth) > col(noise_smooth)
noise_smooth[lower_mask] <- noise_smooth[lower_mask] * 0.8
noise_smooth[!lower_mask] <- noise_smooth[!lower_mask] * 1.2
mat <- signal_mat + 0.2 * noise_smooth
mat <- mat - min(mat)
mat <- mat / max(mat)   # scale to [0,1]
## -------- 2. Split mat into 4 blocky components --------
n <- nrow(mat)
K <- 4               # number of components
block_size <- 10     # side length of each block in cells
# how many blocks in each direction (round up)
nb_row <- ceiling(n / block_size)
nb_col <- ceiling(n / block_size)
# small smoothing kernel (optional, for correlated-looking blocks)
kernel <- matrix(c(1, 2, 1,
2, 4, 2,
1, 2, 1), nrow = 3, byrow = TRUE)
kernel <- kernel / sum(kernel)
smooth2d <- function(mat, kern) {
mat <- as.matrix(mat)
pad <- floor(nrow(kern) / 2)
nr  <- nrow(mat); nc <- ncol(mat)
ext <- matrix(0, nr + 2 * pad, nc + 2 * pad)
ext[(pad + 1):(pad + nr), (pad + 1):(pad + nc)] <- mat
out <- matrix(0, nr, nc)
for (r in 1:nr) {
for (c in 1:nc) {
sub <- ext[r:(r + 2 * pad), c:(c + 2 * pad)]
out[r, c] <- sum(sub * kern)
}
}
out
}
components_raw <- vector("list", K)
set.seed(123)
for (k in 1:K) {
# 1) random value per *square block*
block_vals <- matrix(runif(nb_row * nb_col), nb_row, nb_col)
# 2) expand to a full matrix of squares via kronecker
#    each block is block_size x block_size
base_big <- kronecker(block_vals, matrix(1, block_size, block_size))
# 3) crop to exactly n x n (in case n not multiple of block_size)
base <- base_big[1:n, 1:n]
# 4) optional smoothing to make blocks look correlated, less “lego”
components_raw[[k]] <- smooth2d(base, kernel)
# If you want *crisp* squares, instead do:
# components_raw[[k]] <- base
}
# normalize each raw component to [0, 1]
components_raw <- lapply(components_raw, function(x) {
x <- x - min(x)
x / max(x)
})
# reweight so that the components sum exactly to mat
total_raw <- Reduce("+", components_raw) + 1e-8  # avoid divide-by-zero
components <- lapply(components_raw, function(b) mat * b / total_raw)
# sanity check: max difference should be tiny
max(abs(mat - Reduce("+", components)))
## -------- 3. Plot one or more components --------
plot_comp <- function(comp, title) {
df <- as.data.frame(as.table(comp))
names(df) <- c("i", "j", "z")
ggplot(df, aes(i, j, fill = z)) +
geom_tile() +
scale_fill_gradientn(colors = blues9) +
coord_fixed() +
ggtitle(title) +
theme_minimal()
}
# Example: plot components 1–4
plot_comp(components[[1]], "Component 1")
plot_comp(components[[2]], "Component 2")
plot_comp(components[[3]], "Component 3")
plot_comp(components[[4]], "Component 4")
plot_comp(components[[1]] +
components[[2]] +
components[[3]] +
components[[4]], "Components all")
# Example: plot components 1–4
plot_comp(components[[1]], "Component 1")
plot_comp(components[[2]], "Component 2")
plot_comp(components[[3]], "Component 3")
plot_comp(components[[4]], "Component 4")
plot_comp <- function(comp, title) {
df <- as.data.frame(as.table(comp))
names(df) <- c("i", "j", "z")
ggplot(df, aes(i, j, fill = z)) +
geom_tile() +
scale_fill_gradientn(colors = blues9,
limits = c(0, 1)) +
coord_fixed() +
ggtitle(title) +
theme_minimal()
}
# Example: plot components 1–4
plot_comp(components[[1]], "Component 1")
plot_comp(components[[2]], "Component 2")
plot_comp(components[[3]], "Component 3")
plot_comp(components[[4]], "Component 4")
plot_comp(components[[1]] +
components[[2]] +
components[[3]] +
components[[4]], "Components all")
library(ggplot2)
set.seed(123)
n <- 20
i <- 1:n
j <- 1:n
## -------- 1. Your main matrix 'mat' --------
decay_scale <- 6
band_mat   <- outer(i, j, function(a, b) exp(-abs(a - b) / decay_scale))
trend_mat  <- outer(i, j, function(a, b) {
((n + 1 - a) * (n + 1 - b)) / n^2   # strongest at bottom-left
})
signal_mat <- band_mat * trend_mat
noise_raw <- matrix(rnorm(n * n), n, n)
kernel <- matrix(c(1, 2, 1,
2, 4, 2,
1, 2, 1), nrow = 3, byrow = TRUE)
kernel <- kernel / sum(kernel)
smooth2d <- function(mat, kern) {
pad <- floor(nrow(kern) / 2)
nr  <- nrow(mat); nc <- ncol(mat)
ext <- matrix(0, nr + 2 * pad, nc + 2 * pad)
ext[(pad + 1):(pad + nr), (pad + 1):(pad + nc)] <- mat
out <- matrix(0, nr, nc)
for (r in 1:nr) {
for (c in 1:nc) {
sub <- ext[r:(r + 2 * pad), c:(c + 2 * pad)]
out[r, c] <- sum(sub * kern)
}
}
out
}
noise_smooth <- smooth2d(noise_raw, kernel)
lower_mask <- row(noise_smooth) > col(noise_smooth)
noise_smooth[lower_mask] <- noise_smooth[lower_mask] * 0.8
noise_smooth[!lower_mask] <- noise_smooth[!lower_mask] * 1.2
mat <- signal_mat + 0.2 * noise_smooth
mat <- mat - min(mat)
mat <- mat / max(mat)   # scale to [0,1]
## -------- 2. Split mat into 4 blocky components --------
n <- nrow(mat)
K <- 4               # number of components
block_size <- 10     # side length of each block in cells
# how many blocks in each direction (round up)
nb_row <- ceiling(n / block_size)
nb_col <- ceiling(n / block_size)
# small smoothing kernel (optional, for correlated-looking blocks)
kernel <- matrix(c(1, 2, 1,
2, 4, 2,
1, 2, 1), nrow = 3, byrow = TRUE)
kernel <- kernel / sum(kernel)
smooth2d <- function(mat, kern) {
mat <- as.matrix(mat)
pad <- floor(nrow(kern) / 2)
nr  <- nrow(mat); nc <- ncol(mat)
ext <- matrix(0, nr + 2 * pad, nc + 2 * pad)
ext[(pad + 1):(pad + nr), (pad + 1):(pad + nc)] <- mat
out <- matrix(0, nr, nc)
for (r in 1:nr) {
for (c in 1:nc) {
sub <- ext[r:(r + 2 * pad), c:(c + 2 * pad)]
out[r, c] <- sum(sub * kern)
}
}
out
}
components_raw <- vector("list", K)
set.seed(123)
for (k in 1:K) {
# 1) random value per *square block*
block_vals <- matrix(runif(nb_row * nb_col), nb_row, nb_col)
# 2) expand to a full matrix of squares via kronecker
#    each block is block_size x block_size
base_big <- kronecker(block_vals, matrix(1, block_size, block_size))
# 3) crop to exactly n x n (in case n not multiple of block_size)
base <- base_big[1:n, 1:n]
# 4) optional smoothing to make blocks look correlated, less “lego”
components_raw[[k]] <- smooth2d(base, kernel)
# If you want *crisp* squares, instead do:
# components_raw[[k]] <- base
#
dnn <- levels(cut(0:100, breaks = n, include.lowest = T))
row.names(components_raw[[k]]) <- dnn
colnames(components_raw[[k]]) <- dnn
}
# normalize each raw component to [0, 1]
components_raw <- lapply(components_raw, function(x) {
x <- x - min(x)
x / max(x)
})
# reweight so that the components sum exactly to mat
total_raw <- Reduce("+", components_raw) + 1e-8  # avoid divide-by-zero
components <- lapply(components_raw, function(b) mat * b / total_raw)
# sanity check: max difference should be tiny
max(abs(mat - Reduce("+", components)))
## -------- 3. Plot one or more components --------
plot_comp <- function(comp, title) {
df <- as.data.frame(as.table(comp))
names(df) <- c("i", "j", "z")
ggplot(df, aes(i, j, fill = z)) +
geom_tile() +
scale_fill_gradientn(colors = blues9,
limits = c(0, 1)) +
coord_fixed() +
ggtitle(title) +
theme_minimal()
}
# Example: plot components 1–4
plot_comp(components[[1]], "Component 1")
plot_comp(components[[2]], "Component 2")
plot_comp(components[[3]], "Component 3")
plot_comp(components[[4]], "Component 4")
plot_comp(components[[1]] +
components[[2]] +
components[[3]] +
components[[4]], "Components all")
#
components[[1]]
library(writexl)
## -------- 4. Write to XLSX --------
install.packages("writexl")  # if you don't have it yet
# assume 'components' is your list of matrices
# convert each matrix to a data frame for Excel
full_comp <- components[[1]] +
components[[2]] +
components[[3]] +
components[[4]]
components_dfs <- lapply(list(components, full_comp), as.data.frame)
# give each sheet a name
names(components_dfs) <- c(paste0("component_", 1:4),"components_full")
components[[5]] <- full_comp
components_dfs <- lapply(components, as.data.frame)
# give each sheet a name
names(components_dfs) <- c(paste0("component_", 1:4),"components_full")
# write to a single Excel workbook
write_xlsx(components_dfs, "components_decomposition.xlsx")
## -------- 4. Write to XLSX --------
library(writexl)
# write to a single Excel workbook
write_xlsx(components_dfs, "components_decomposition.xlsx")
row.names(components_dfs)
