# ///////////////////////////////////////////
# ===========================================
class infections_by_grp(ss.Analyzer):
""" Count infections by age and location"""
def __init__(self, age_bins=(0, 20, 100)):
super().__init__()
self.age_bins = age_bins
self.mins = age_bins[:-1]
self.maxes = age_bins[1:]
self.hist = {
min_age: {'urban': [], 'rural': []}
for min_age in self.mins
}
return
def init_pre(self, sim):
super().init_pre(sim)
self.infections = np.zeros(len(self.sim.people.age))
return
def step(self):
age = self.sim.people.age
urban = self.sim.people.urban
disease = self.sim.diseases[0]
for min_age, max_age in zip(self.mins, self.maxes):
mask_age = (age >= min_age) & (age < max_age)
# Urban
mask_urban = (mask_age) & (urban == True)
self.hist[min_age]['urban'].append(disease.infected[mask_urban].sum())
# Rural
mask_rural = (mask_age) & (urban == False)
self.hist[min_age]['rural'].append(disease.infected[mask_rural].sum())
return
def plot(self):
plt.figure()
x = self.sim.t.tvec
for min_age, max_age in zip(self.mins, self.maxes):
# Urban line
plt.plot(
x,
self.hist[min_age]['urban'],
label=f'Age {min_age}-{max_age} urban'
)
# Rural line (dashed)
plt.plot(
x,
self.hist[min_age]['rural'],
linestyle='--',
label=f'Age {min_age}-{max_age} rural'
)
plt.legend(frameon=False)
plt.xlabel('Model time')
plt.ylabel('Individuals infected')
plt.ylim(bottom=0)
sc.boxoff()
plt.show()
return
# ===========================================
# ///////////////////////////////////////////
# RUN
# ///////////////////////////////////////////
# ===========================================
sim = ss.Sim(
diseases = 'sir',
networks = mps,
people   = ppl,
analyzers = infections_by_grp(),
start = 2000,
stop = 2010,
dt = 0.1)
# start = 2000,
# stop = 2010,
# dt = ss.years(0.1)
sim.init(reset = True)
sim.run()
sim.analyzers.infections_by_grp.plot()
import numpy as np
import pandas as pd
import sciris as sc
import starsim as ss
import matplotlib.pyplot as plt
# ===========================================
# ///////////////////////////////////////////
# AGE MATRIX -> People object
#
# there is some randomness which is introduced here
# right now i just have people in ages 10 and 20 so it
# splits across the break in age groups below
# ///////////////////////////////////////////
# ===========================================
# import the age matrix
age_data = pd.read_csv('age.csv')
# from the K01 the 3 location states are
# within-household, in schools, or in the community
# create a location state
def state_household(n):
""" Make a function to randomly assign people
to urban/rural locations """
return np.random.choice(a=[True, False], p=[0.5, 0.5], size=n)
urban = ss.BoolState('urban', default=urban_function)
# create a location state
def urban_function(n):
""" Make a function to randomly assign people
to urban/rural locations """
return np.random.choice(a=[True, False], p=[0.5, 0.5], size=n)
urban2 = ss.BoolState('urban2', default=urban_function)
# make the people object
# NB: (1) n_agents needs to be large enough for things
#     to conform to expectations
#     (2) added a location state that we can use later
ppl = ss.People(n_agents=1e5,
age_data=age_data,
extra_states=[urban, urban2])
ppl.init_mock()
# ===========================================
# ///////////////////////////////////////////
# MIXING POOLS
# ///////////////////////////////////////////
# ===========================================
mps = ss.MixingPools(
# Options for this are: 'sir', 'sis', ...
diseases = 'seir',
# overall transmission via these mixing pools
# NB: Need to understand what this actually means
beta = 1.2,
# SOURCE
# NB: Make these a lambda sim so you can define locations
src = {'0-20 - URBAN': lambda sim: ((sim.people.age < 20) &
(sim.people.urban == True)).uids,
'0-20 - RURAL': lambda sim: ((sim.people.age < 20) &
(sim.people.urban == False)).uids,
'20+ - URBAN': lambda sim: ((sim.people.age >= 20) &
(sim.people.urban == True)).uids,
'20+ - RURAL': lambda sim: ((sim.people.age >= 20) &
(sim.people.urban == False)).uids},
# DESTINATION
dst = {'0-20 - URBAN': lambda sim: ((sim.people.age < 20) &
(sim.people.urban == True)).uids,
'0-20 - RURAL': lambda sim: ((sim.people.age < 20) &
(sim.people.urban == False)).uids,
'20+ - URBAN': lambda sim: ((sim.people.age >= 20) &
(sim.people.urban == True)).uids,
'20+ - RURAL': lambda sim: ((sim.people.age >= 20) &
(sim.people.urban == False)).uids},
# CONTACT MATRIX
# the column is destination, the row is source
# dest: A  B
#      [0, 0]
#      [1, 0]
# means coming from B -> A, so only A increases
n_contacts = np.multiply(
[[1.0, 1.0, 1.0, 1.0],
[10.0, 1.0, 1.0, 1.0],
[1.0, 1.0, 1.0, 1.0],
[1.0, 1.0, 1.0, 1.0]], 10)
)
# ===========================================
# ///////////////////////////////////////////
# Analyzer
# ///////////////////////////////////////////
# ===========================================
class infections_by_grp(ss.Analyzer):
""" Count infections by age and location"""
def __init__(self, age_bins=(0, 20, 100)):
super().__init__()
self.age_bins = age_bins
self.mins = age_bins[:-1]
self.maxes = age_bins[1:]
self.hist = {
min_age: {'urban': [], 'rural': []}
for min_age in self.mins
}
return
def init_pre(self, sim):
super().init_pre(sim)
self.infections = np.zeros(len(self.sim.people.age))
return
def step(self):
age = self.sim.people.age
urban = self.sim.people.urban
disease = self.sim.diseases[0]
for min_age, max_age in zip(self.mins, self.maxes):
mask_age = (age >= min_age) & (age < max_age)
# Urban
mask_urban = (mask_age) & (urban == True)
self.hist[min_age]['urban'].append(disease.infected[mask_urban].sum())
# Rural
mask_rural = (mask_age) & (urban == False)
self.hist[min_age]['rural'].append(disease.infected[mask_rural].sum())
return
def plot(self):
plt.figure()
x = self.sim.t.tvec
for min_age, max_age in zip(self.mins, self.maxes):
# Urban line
plt.plot(
x,
self.hist[min_age]['urban'],
label=f'Age {min_age}-{max_age} urban'
)
# Rural line (dashed)
plt.plot(
x,
self.hist[min_age]['rural'],
linestyle='--',
label=f'Age {min_age}-{max_age} rural'
)
plt.legend(frameon=False)
plt.xlabel('Model time')
plt.ylabel('Individuals infected')
plt.ylim(bottom=0)
sc.boxoff()
plt.show()
return
# ===========================================
# ///////////////////////////////////////////
# RUN
# ///////////////////////////////////////////
# ===========================================
sim.init(reset = True)
sim = ss.Sim(
diseases = 'sir',
networks = mps,
people   = ppl,
analyzers = infections_by_grp(),
start = 2000,
stop = 2010,
dt = 0.1)
# start = 2000,
# stop = 2010,
# dt = ss.years(0.1)
sim.run()
sim.analyzers.infections_by_grp.plot()
import numpy as np
import pandas as pd
import sciris as sc
import starsim as ss
import matplotlib.pyplot as plt
# ===========================================
# ///////////////////////////////////////////
# AGE MATRIX -> People object
#
# there is some randomness which is introduced here
# right now i just have people in ages 10 and 20 so it
# splits across the break in age groups below
# ///////////////////////////////////////////
# ===========================================
# import the age matrix
age_data = pd.read_csv('age.csv')
# from the K01 the 3 location states are
# within-household, in schools, or in the community
# create a location state
def state_household(n):
""" Make a function to randomly assign people
to urban/rural locations """
return np.random.choice(a=[True, False], p=[0.5, 0.5], size=n)
urban = ss.BoolState('urban', default=urban_function)
# create a location state
def urban_function(n):
""" Make a function to randomly assign people
to urban/rural locations """
return np.random.choice(a=[True, False], p=[0.5, 0.5], size=n)
urban2 = ss.BoolState('urban2', default=urban_function)
# make the people object
# NB: (1) n_agents needs to be large enough for things
#     to conform to expectations
#     (2) added a location state that we can use later
ppl = ss.People(n_agents=1e5,
age_data=age_data,
extra_states=[urban, urban2])
ppl.init_mock()
# ===========================================
# ///////////////////////////////////////////
# MIXING POOLS
# ///////////////////////////////////////////
# ===========================================
mps = ss.MixingPools(
# Options for this are: 'sir', 'sis', ...
diseases = 'seir',
# overall transmission via these mixing pools
# NB: Need to understand what this actually means
beta = 1.2,
# SOURCE
# NB: Make these a lambda sim so you can define locations
src = {'0-20 - URBAN': lambda sim: ((sim.people.age < 20) &
(sim.people.urban == True)).uids,
'0-20 - RURAL': lambda sim: ((sim.people.age < 20) &
(sim.people.urban == False)).uids,
'20+ - URBAN': lambda sim: ((sim.people.age >= 20) &
(sim.people.urban == True)).uids,
'20+ - RURAL': lambda sim: ((sim.people.age >= 20) &
(sim.people.urban == False)).uids},
# DESTINATION
dst = {'0-20 - URBAN': lambda sim: ((sim.people.age < 20) &
(sim.people.urban == True)).uids,
'0-20 - RURAL': lambda sim: ((sim.people.age < 20) &
(sim.people.urban == False)).uids,
'20+ - URBAN': lambda sim: ((sim.people.age >= 20) &
(sim.people.urban == True)).uids,
'20+ - RURAL': lambda sim: ((sim.people.age >= 20) &
(sim.people.urban == False)).uids},
# CONTACT MATRIX
# the column is destination, the row is source
# dest: A  B
#      [0, 0]
#      [1, 0]
# means coming from B -> A, so only A increases
n_contacts = np.multiply(
[[1.0, 1.0, 1.0, 1.0],
[10.0, 1.0, 1.0, 1.0],
[1.0, 1.0, 1.0, 1.0],
[1.0, 1.0, 1.0, 1.0]], 10)
)
# ===========================================
# ///////////////////////////////////////////
# Analyzer
# ///////////////////////////////////////////
# ===========================================
class infections_by_grp(ss.Analyzer):
""" Count infections by age and location"""
def __init__(self, age_bins=(0, 20, 100)):
super().__init__()
self.age_bins = age_bins
self.mins = age_bins[:-1]
self.maxes = age_bins[1:]
self.hist = {
min_age: {'urban': [], 'rural': []}
for min_age in self.mins
}
return
def init_pre(self, sim):
super().init_pre(sim)
self.infections = np.zeros(len(self.sim.people.age))
return
def step(self):
age = self.sim.people.age
urban = self.sim.people.urban
disease = self.sim.diseases[0]
for min_age, max_age in zip(self.mins, self.maxes):
mask_age = (age >= min_age) & (age < max_age)
# Urban
mask_urban = (mask_age) & (urban == True)
self.hist[min_age]['urban'].append(disease.infected[mask_urban].sum())
# Rural
mask_rural = (mask_age) & (urban == False)
self.hist[min_age]['rural'].append(disease.infected[mask_rural].sum())
return
def plot(self):
plt.figure()
x = self.sim.t.tvec
for min_age, max_age in zip(self.mins, self.maxes):
# Urban line
plt.plot(
x,
self.hist[min_age]['urban'],
label=f'Age {min_age}-{max_age} urban'
)
# Rural line (dashed)
plt.plot(
x,
self.hist[min_age]['rural'],
linestyle='--',
label=f'Age {min_age}-{max_age} rural'
)
plt.legend(frameon=False)
plt.xlabel('Model time')
plt.ylabel('Individuals infected')
plt.ylim(bottom=0)
sc.boxoff()
plt.show()
return
# ===========================================
# ///////////////////////////////////////////
# RUN
# ///////////////////////////////////////////
# ===========================================
ss.init(reset = True)
sim = ss.Sim(
diseases = 'sir',
networks = mps,
people   = ppl,
analyzers = infections_by_grp(),
start = 2000,
stop = 2010,
dt = 0.1)
# start = 2000,
# stop = 2010,
# dt = ss.years(0.1)
sim.run()
sim.analyzers.infections_by_grp.plot()
ppl.to_df()
def init_debut(module, sim, uids):
# Test setting the mean debut age by sex, 16 for men and 21 for women.
loc = np.full(len(uids), 16)
loc[sim.people.female[uids]] = 21
return loc
mf_pars = {
'debut': ss.normal(loc=init_debut, scale=2),  # Age of debut can vary by using callable parameter values
}
sim_pars = {'networks': [ss.MFNet(**mf_pars)], 'n_agents': small}
gon_pars = {'beta': {'mf': [0.08, 0.04]}}
gon = sse.Gonorrhea(**gon_pars)
sim = ss.Sim(pars=sim_pars, diseases=[gon])
sim.init()
sim.run()
if do_plot:
plt.figure()
plt.plot(sim.timevec, sim.results.gonorrhea.n_infected)
plt.title('Number of gonorrhea infections')
def init_debut(module, sim, uids):
# Test setting the mean debut age by sex, 16 for men and 21 for women.
loc = np.full(len(uids), 16)
loc[sim.people.female[uids]] = 21
return loc
mf_pars = {
'debut': ss.normal(loc=init_debut, scale=2),  # Age of debut can vary by using callable parameter values
}
sim_pars = {'networks': [ss.MFNet(**mf_pars)], 'n_agents': small}
gon_pars = {'beta': {'mf': [0.08, 0.04]}}
gon = sse.Gonorrhea(**gon_pars)
sim = ss.Sim(pars=sim_pars, diseases=[gon])
sim.init()
sim.run()
if do_plot:
plt.figure()
plt.plot(sim.timevec, sim.results.gonorrhea.n_infected)
plt.title('Number of gonorrhea infections')
def init_debut(module, sim, uids):
# Test setting the mean debut age by sex, 16 for men and 21 for women.
loc = np.full(len(uids), 16)
loc[sim.people.female[uids]] = 21
return loc
mf_pars = {
'debut': ss.normal(loc=init_debut, scale=2),  # Age of debut can vary by using callable parameter values
}
sim_pars = {'networks': [ss.MFNet(**mf_pars)], 'n_agents': small}
gon_pars = {'beta': {'mf': [0.08, 0.04]}}
gon = sse.Gonorrhea(**gon_pars)
sim = ss.Sim(pars=sim_pars, diseases=[gon])
import sciris as sc
import numpy as np
import starsim as ss
import starsim_examples as sse
import matplotlib.pyplot as plt
import pytest
def init_debut(module, sim, uids):
# Test setting the mean debut age by sex, 16 for men and 21 for women.
loc = np.full(len(uids), 16)
loc[sim.people.female[uids]] = 21
return loc
mf_pars = {
'debut': ss.normal(loc=init_debut, scale=2),  # Age of debut can vary by using callable parameter values
}
sim_pars = {'networks': [ss.MFNet(**mf_pars)], 'n_agents': small}
gon_pars = {'beta': {'mf': [0.08, 0.04]}}
gon = sse.Gonorrhea(**gon_pars)
sim = ss.Sim(pars=sim_pars, diseases=[gon])
sim.init()
sim.run()
if do_plot:
plt.figure()
plt.plot(sim.timevec, sim.results.gonorrhea.n_infected)
plt.title('Number of gonorrhea infections')
import sciris as sc
import numpy as np
import starsim as ss
import starsim_examples as sse
import matplotlib.pyplot as plt
import pytest
small = 100
def init_debut(module, sim, uids):
# Test setting the mean debut age by sex, 16 for men and 21 for women.
loc = np.full(len(uids), 16)
loc[sim.people.female[uids]] = 21
return loc
mf_pars = {
'debut': ss.normal(loc=init_debut, scale=2),  # Age of debut can vary by using callable parameter values
}
sim_pars = {'networks': [ss.MFNet(**mf_pars)], 'n_agents': small}
gon_pars = {'beta': {'mf': [0.08, 0.04]}}
gon = sse.Gonorrhea(**gon_pars)
sim = ss.Sim(pars=sim_pars, diseases=[gon])
sim.init()
sim.run()
if do_plot:
plt.figure()
plt.plot(sim.timevec, sim.results.gonorrhea.n_infected)
plt.title('Number of gonorrhea infections')
plt.title('Number of gonorrhea infections')
plt.figure()
plt.plot(sim.timevec, sim.results.gonorrhea.n_infected)
plt.title('Number of gonorrhea infections')
# Possible to initialize people with extra states, e.g. a geolocation
def geo_func(n):
locs = [1,2,3]
return np.random.choice(locs, n)
extra_states = [
ss.FloatArr('geolocation', default=geo_func),
]
ppl = ss.People(small, extra_states=extra_states)
# Possible to add a module to people outside a sim (not typical workflow)
ppl.add_module(sse.HIV())
ppl.to_df()
def geo_func(n):
locs = [1,2,3]
return np.random.choice(locs, n)
extra_states = [
ss.FloatArr('geolocation', default=geo_func),
]
ppl = ss.People(small, extra_states=extra_states)
def geo_func(n):
locs = [1,2,3]
return np.random.choice(locs, n)
extra_states = [ss.FloatArr('geolocation', default=geo_func)]
